#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <getopt.h>
#include <stdlib.h>
#include <time.h>
#include <fstream>
#include <cstdlib>
#include <vector>
#include <iostream>
#include <string>
#include <sstream>
#include <unordered_map>

struct send_message {
    uint8_t operation;
    char key[16];
    char value[32];
};

struct response_message {
    uint8_t status_code;
    char key[16];
    char value[32];
};

//Compares the received response message and the expected response message to check for correctness
double compareResp(struct response_message resp, struct response_message checkresp){
	double total = 0;
	double correct = 0;
	for(int i=0; i<16; i++)
	{	total++;
		if(resp.key[i]==checkresp.key[i]) correct++;//return 0;
	}
	for(int j=0; j<32; j++)
	{	total++;
		if(resp.value[j]==checkresp.value[j])correct++;// return 0;
	}
	return correct/total;
}


//Creates a send_message struct vector from the string token taken from strace output
//struct send_message parseSend(std::string token){
std::vector<struct send_message> *parseSend(std::string token){
	struct send_message send;
	std::vector<struct send_message> *sendvector = new std::vector<struct send_message>();
	memset(send.key, 0, 16*sizeof(char));
	memset(send.value, 0, 32*sizeof(char));
	send.operation = stoi(token.substr(2, 1));
	int keyindex = 0;
	int valueindex = 0;
	int currentindex = 3;
	char currentchar;
	std::string nums = "0123456789";
	int number;
	while(token[currentindex]!='"')
	{
		if(token[currentindex]=='\\')
		{
			currentindex++;
			number = 0;
			while(nums.find(token[currentindex]) != std::string::npos)
			{
				number = number*10 + std::stoi(std::string(token.substr(currentindex, 1)));
				currentindex++;
			}
			currentindex--;
			currentchar = number;
		}
		else
		{
			currentchar = token[currentindex];
		}
		if(keyindex<16)
		{
			send.key[keyindex] = currentchar;
			currentchar = '?';
			keyindex++;
		}
		if(keyindex>=16 and valueindex<32 and currentchar!='?')
		{
			send.value[valueindex] = currentchar;
			valueindex++;
		}
		currentindex++;
		if(keyindex==16 and valueindex==32){
			std::cout << std::string(send.key, 16) << "\n";
			sendvector->push_back(send);
			if(token[currentindex]!='"')
			{
				keyindex = 0;
				valueindex = 0;
				currentindex++;
				send.operation = stoi(token.substr(currentindex, 1));
				memset(send.key, 0, 16*sizeof(char));
				memset(send.value, 0, 32*sizeof(char));
				currentindex++;
				
			}
		}
	};
	return sendvector;
}

//Creates a response_message struct vector based on the string token from the output of strace
//struct response_message parseResponse(std::string token){
std::vector<struct response_message> *parseResponse(std::string token){
	struct response_message resp;
	std::vector<struct response_message> *responsevector = new std::vector<struct response_message>();
	memset(resp.key, 0, 16*sizeof(char));
	memset(resp.value, 0, 32*sizeof(char));
	resp.status_code= (uint8_t)stoi(token.substr(2, 1));
	int keyindex = 0;
	int valueindex = 0;
	int currentindex = 3;
	char currentchar;
	std::string nums = "01234567890";
	int number;
	while(token[currentindex]!='"' and valueindex<32)
	{;
		if(token[currentindex]=='\\')
		{
			currentindex++;
			number = 0;
			while(nums.find(token[currentindex]) != std::string::npos)
			{
				number = number*10 + std::stoi(token.substr(currentindex, 1));
				currentindex++;
			}
			currentindex--;
			currentchar = number;
		}
		else
		{
			currentchar = token[currentindex];
		}
		if(keyindex<16)
		{
			resp.key[keyindex] = currentchar;
			currentchar = '?';
			keyindex++;
		}
		if(keyindex>=16 and valueindex<32 and currentchar != '?')
		{
			resp.value[valueindex] = currentchar;
			valueindex++;
		}
		currentindex++;
		if(keyindex==16 and valueindex==32){
			responsevector->push_back(resp);
			if(token[currentindex]!='"')
			{
				keyindex = 0;
				valueindex = 0;
				currentindex++;
				resp.status_code = stoi(token.substr(currentindex, 1));
				memset(resp.key, 0, 16*sizeof(char));
				memset(resp.value, 0, 32*sizeof(char));
				currentindex++;
				
			}
		}
	}
	return responsevector;
}

//Takes the output file generated by redooutput.c and looks at the send and recv system calls that occured
//and checks that the proper response message structs were sent back by the server
//Includes code to parse the send and response messages sent by the client and server
int main(int argc, char* argv[])
{
	std::string outputfilename = "output2.txt";
	if(argc>1) outputfilename = std::string(argv[1]);
	std::ifstream ofs;
	ofs.open(outputfilename.c_str());
	std::string line;
	std::unordered_map<std::string, std::string> *hashmap = new std::unordered_map<std::string, std::string>();
	std::unordered_map<std::string, std::vector<struct response_message> *> *checkmap = new std::unordered_map<std::string, std::vector<struct response_message> *>();
	std::string pid;
	std::string token;
	std::string substring;
	char key[16];
	char value[32];
	double correctcount = 0;
	double totalcount = 0;
	while(std::getline(ofs, line))
	{
		std::istringstream linestream(line);
		
		linestream >> pid >> token;
		if(token.find("sendto") != std::string::npos or token.find("send") != std::string::npos)
		{
			totalcount++;
			linestream >> token;
			std::vector<struct send_message> *sendvector = parseSend(token);
			std::vector<struct response_message> *responsevector = new std::vector<struct response_message>();
			
			//For each send message that was sent, a response message containing the expected correct response of the
			//server is constructed and the final vector of expected response is put into the checkmap hashmap
			for(struct send_message send : *sendvector)
			{
				struct response_message expectedresponse;
				memset(expectedresponse.key, 0, 16);
				memset(expectedresponse.value, 0, 32);
				memcpy(expectedresponse.key, send.key, 16);
				if(send.operation==0)
				{
				
					auto item = hashmap->find(std::string(send.key, 16));
					if(hashmap->count(std::string(send.key, 16))==1)
					{
						memcpy(expectedresponse.value, hashmap->at(std::string(send.key, 16)).c_str(), 16);
					}
				
				}
				else
				{	
					memcpy(expectedresponse.value, send.value, 32);
					std::string sendkey = std::string(send.key, 16);
					std::string sendvalue = std::string(send.value, 32);
					if(hashmap->count(sendkey)==0)
					{	
						hashmap->insert(std::make_pair(sendkey, sendvalue));
					}
					else
					{
						hashmap->find(sendkey)->second = sendvalue;
					}
				}
				responsevector->push_back(expectedresponse);
			}
			if(checkmap->count(pid)==0){
				checkmap->insert(std::make_pair(pid, responsevector));
			}
			else
			{
				checkmap->find(pid)->second = responsevector;;
			}
		}

		//If something was received then the response message is created and compared to the correct response message
		//put in 
		else if(token.find("recvfrom") != std::string::npos or token.find("recv") != std::string::npos)
		{
			linestream >> token;
			std::vector<struct response_message> *responsevector = parseResponse(token);
			std::vector<struct response_message> *checkresp = checkmap->at(pid);
			if(responsevector == checkresp)
			{
				correctcount += 1;//compareResp(resp, checkresp);
			}
;
		}
	}
	std::cout << correctcount/totalcount << "\n";
}















